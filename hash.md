# HASH
懂得都懂
## 常用hash函数
+ 直接定址法：取关键字或关键字的某个线性函数值为散列地址，这个线性函数的定义多种多样，没有标准。
+ 数字分析法：假设关键字以r为基，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
+ 平方取中法：取关键字平方后的中间几位为哈希地址，取的位数由表长决定。
+ 折叠法：将关键字分割为位数相同的几部分，然后取这几部分的叠加和作为哈希地址。
+ 取模法：也可以在折叠法和平方取中法运算后再取模。

## 缓存系统负载均衡和一致性哈希
缓存系统负载均衡可以用轮询和哈希两种方法（最少连接数）。
1. 轮询就是指每次来的请求交由一个服务器解决，下次的请求交给下一个服务器解决，轮询整个服务器集群。优点就是实现简单，但服务器可能处于不同的硬件环境下，性能和网络环境的差异被简单的忽略了，因此，提出了一种改进的加权轮询算法，可以根据硬件性能配置实例负载的权重，达到资源的合理利用。算法并不复杂，维护一个当前权重，初始设定为最大权重，遍历每个实例，找到满足权重大于等于当前权重的实例，所有实例被遍历后，当前权重减掉所有权重的最大公约数。但这种方法也同样带来了问题，假设权重{5，1，1}，那么多次请求将全部分配到1号机上，这是不可接受的，因此引入了平滑加权轮询，这种方法也被nginx采用，每个服务器都有两个权重变量：weight，配置文件中指定的该服务器的权重，这个值是固定不变的。current_weight，服务器目前的权重。一开始为0，之后会动态调整。每次当请求到来，选取服务器时，会遍历数组中所有服务器。对于每个服务器，让它的current_weight增加它的weight；同时累加所有服务器的weight，并保存为total。
遍历完所有服务器之后，如果该服务器的current_weight是最大的，就选择这个服务器处理本次请求。最后把该服务器的current_weight减去total.
2. 也可使使用哈希函数，把请求打散随机分配到缓存集群中。常用MurmuHash，但普通哈希函数对于负载均衡的扩展性和容错性很差，服务器需要动态扩容缩容，新加进的服务器会使原有的Hash值不准确，为了达到负载均衡的效果，要重新计算并更新哈希值，对于更新后哈希值不一致的缓存数据，要迁移到更新后的节点上。同时，假设缩容，或者服务器集群中的某个服务器宕机该结点上的数据需要迁移。因此引入一致性哈希，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-$ 2^32-1 $,即哈希值是一个32位无符号整数，整个空间按顺时针方向组织，0和$ 2^32-1 $在0重合，选择服务器的ip或主机作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，使用算法定位数据访问相应服务器，将数据key使用相同的函数计算出hash值，并确定此数据在换上的位置，沿环顺时针走，遇到的第一台服务器就是其定位到的服务器。如果一台服务器不可用，受影响的只有其相邻的数据，其他不受影响。因为一致性哈希对于节点的增减都只需重新定位环空间中的一小部分数据，具有较好的容错性和可扩展性。另外一致性哈希算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜和节点雪崩（大量数据倾斜在一个节点，该节点崩溃，同时后续节点要接受前面所有数据，继续崩溃），为了解决这种问题，一致性哈希算法引入了虚拟节点机制，即对每个服务节点计算多个哈希，每个计算结果都放置一个服务节点，称为虚拟节点， 具体做法可以在服务器ip或主机号后面增加编号，数据定位算法不变，多了一步虚拟节点到实际节点的映射，通常将虚拟节点个数定义较大，能保证较少节点的情况下数据节点分配均匀。
