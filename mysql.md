# Mysql

## 逻辑架构
+ 最上层：大多数基于网络的客户端/服务器的工具或服务都有类似的架构，比如：连接管理，授权认证，安全。
+ 第二层：大多数的Mysql的核心服务都在这层，包括查询解析，分析优化，缓存以及所有的内置函数，所有的跨存储引擎的功能都在这一层实现，如储存过程，触发器，视图等。
+ 第三层：储存引擎。

## SQL四种语言
1. DDL: data definition language 用于定义数据库的三级结构，包括外模式，概念模式，内模式及其相互之间的映像，定义数据的完整性，安全控制等约束。模式就是指schema。包括CREATE、ALTER、DROP、TRUNCATE（用于删除表中的所有行且不记录单个行的删除操作，与没有where子句的DELETE语句类似，但是TRUNCATE速度更快，使用的系统资源和事务日志资源更少）、COMMENT、RENAME
  + 外模式：对应数据库的升级、外模式包括(子模式，用户模式)用来描述用户看到或使用那部分的数据的逻辑结构，用户根据外模式用户数据操作语句或者程序操作数据库中的数据，外模式的主要特点用来描述组成用户视图各个记录的组成、相互联系、数据的完整性、数据项的特征等。
  + 概念模式：概念模式（概念、逻辑模式）用以描述整个数据库中的逻辑结构、用来描述现实生活中的实体，以及他们之间的关系、从而定义记录数据项的完整性约束条件以及记录之间的联系是数据项的框架，概念模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户数据的公共数据视图。
  + 内模式：内模式对应物理级数据库，内模式是所有模式最底层的表示，不同于物理层，假设外存是一个无限性的地址空间，内模式是储存记录的类型，储存域，以及储存记录的物理顺序，即元索引，和储存路径等数据的存储组织从而形成一个完整的系统。
2. DML：DATA manipulation language数据操纵语言 分为交互型和嵌入型DML，也可分为过程型DML和非过程型DML，包括SELECT、INSERT、UPDATE、DELETE、MERGE、CALL、EXPLAIN PLAN、LOCK TABLE
3. DCL：DATA control language数据库控制语言 GRANT授权，REVOKE取消授权
4. TCL：Transaction Control Language事务控制语言 SAVEPOINT 设置保存点，ROLLBACK 回滚，SET TRANSACTION

## 索引
+ ### 索引的优点
  1. 索引可以让服务器快速定位到表的指定位置。
  2. 索引大大减少了服务器需要扫描的数据量。
  3. 索引可以帮助服务器避免排序和临时表。
  4. 索引可以将随机IO变为顺序IO。
+ ### 索引的三星系统原则
  1. 索引将相关的记录放到一起则获得一星
  2. 如果索引中的数据顺序和查找中的排列顺序一致将获得二星
  3. 如果索引中的列包含了查询中需要的全部列则获得三星
+ ### B-Tree索引
  B-Tree索引适用于全键值，键值范围或键前缀查找，键前缀查找只适用根据最左前缀的查找，对如下类型的查询有效：
  1. 全值匹配：全值匹配指的是和索引中的所有列进行匹配。
  2. 匹配最左前缀：查找所有姓为Allen的人，即只使用索引的第一列。
  3. 匹配列前缀：可以匹配莫一列的值的开头部分，可以查找所有以J开头的姓的人。
  4. 匹配范围值：可用于查找在Allen和Barrymore之间的人。
  5. 精确匹配某一列并范围匹配另外一列：可用于查找所有姓为Allen，并且名字是字母K开头的人，即第一列全匹配，第二列范围匹配。
  6. 只访问索引的查询：B-Tree通常可以支持聚簇索引，即查询值需要访问索引，而无须访问数据行。
+ B-Tree索引的限制
  因为索引树的节点时有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作(按序查找)，一般来说，如果B-tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序，所以，如果ORDER BY自居满足下面的查询类型，则这个索引也可以满足对应的排序需求。
  在优化性能时，可能需要使用相同的列，但顺序不同的索引来满足不同类型的查询需求。索引的顺序很重要。
  1. 如果不是按照索引的最左列开始查找，则无法使用索引。
  2. 不能跳过索引中的列。
  3. 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。
+ ### hash索引
  哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效，对于每一行数据，储存引擎都会对所有的索引列计算一个哈希码，哈希码时一个较小的值，并且不同的键值的行计算出来的哈希码也不一样，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
```sql
CREATE TABLE testhash(
  fname VARCHAR(50) NOT NULL,
  lname VARCHAR(50) NOT NULL,
  KEY USING HASH(fname)
)ENGINE=MEMORY;
```
+ hash索引的限制
  1. 哈希索引值包含哈希值和行指针，而不存储字段值所以不能使用索引中的值来避免读取行，不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
  2. 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
  3. 哈希索引也不支持部分索引匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值。
  4. 哈希索引只支持等值比较查询，包括=，IN(),<=>。也不支持任何范围查询，例如WHERE > 100。
  5. 访问哈希索引的数据非常快，除非有很多哈希冲突。
  6. 如果哈希冲突很多的话，一些索引维护操作的代价会很高。

+ 自定义哈希索引
  在B-Tree基础上创建一个伪hash索引，这和真正的hash索引不是一回事，因为还是使用B-Tree进行查找，但是使用哈希值而不是键值本身进行索引查找。但需要考虑到如果hash冲突，不单单影响效率，查询结果会返回多行，需要过滤。
  如此一来，如果需要为url使用btree索引，那么需要储存的内容将会很大，因为URL本身都很长。所以自定义哈希索引的作用之一就是只需要很小的索引就可以为超长的键创建索引。
  InooDB引擎有一个特殊的功能叫做自适应哈希索引，当InooDB注意到某些索引值被使用得非常频繁时，他会在内存中基于btree索引再创建一个哈希索引，这样就让btree索引也具有一些哈希所以的优点。
  ```sql
  CREATE TABLE pseudohash(
    id int unsigned NOT NULL auto_increment,
    url varchar(255) NOT NULL,
    url_crc int unsigned NOT NULL DEFAULT 0,
    PRIMARY KEY(id)
  );
  DELIMITER //
  CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON
  pseudohash FOR EACH ROW BEGIN SET NEW.url_crc=crc32(NEW.URL);
  END;
  //
  CREATE TRIGGER pseudohash_crc_upd BEFORE UPDATE ON
  pseudohash FOR EACH ROW BEGIN
  SET NEW.url_crc=crc32(NEW.url);
  NED;
  //
  DELIMITER ;
  ```
+ 高性能索引策略
  1. 独立的列：索引列不能时表达式的一部分，也不能是函数的参数。不当的使用索引，或者使得Mysql无法使用已有的索引。例如：
  ```sql
  SELECT actor_id from sakila.actor WHERE actor_id + 1 = 5;
  SELECT .... WHERE TO_DAYS(CURRENT_DATE)-TO_DAYS(data_col)<=10;
  ```
  Mysql无法自动解析方程式，我们应该养成简化WHERE条件的习惯。
  2. 前缀索引和索引选择性
  索引选择性是指不重复的索引值和数据表的记录总数，从1/#T到1之间，选择性高的索引能过滤更多的行。
  有时候需要索引很长的字符列，这会让索引变得大且慢，一个策略是前面提到的模拟哈希索引，但有时候这样做还不够。
  一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能，对于BLOB，TEXT或者更长的VARCHAR类型的列，必须使用前缀索引，因为Mysql不允许若因这些列的完整长度。所以，前缀索引的诀窍在于选择足够长的前缀以保证较高的选择性，同时又不能太长，以便节约空间，前缀的基数应该接近完整列的基数。
  计算合适的前缀长度的办法：
    1. 假设现在的索引列是城市名，那么，我们先找到最常见的城市列表：
    ```sql
    SELECT COUNT(*) AS cnt, city
    FROM sakila.city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;
    ```
    然后，我们试探前缀长：
    ```sql
    SELECT COUNT(*) AS cnt, LEFT(city,3) AS pref
    FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10
    ```
    比对这两个结果，如果差点意思，增加前缀长，直到前缀基数接近完整基数。
    2. 另一个办法是，计算列的选择性，并使前缀的选择性接近于完整列的选择性。
    ```sql
    SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
    SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*) AS sel3;
    ```
    这是平均情况，还要考虑最坏情况。
  创建前缀索引的方法
  ```sql
  ALTER TABLE sakila.city_demo ADD KEY(city(7));
  ```
  缺点：无法用于ORDER BY和GROUP BY,也无法使用前缀索引做覆盖扫描。
  一个常见的业务场景：
  存储网站的session基于Mysql，那么需要在一个很长的十六进制字符串上创建索引，此时，如果采用长度为8的前缀索引通常能显著地提升性能。
  有时候，后缀索引也有用途，例如，找到某个域名的所有电子邮件地址，Mysql并不支持反向索引，但可以把字符串反转后存储，并基于此建立前缀索引，可以用触发器维护这种索引。
  3. 多列索引
  在多个列上建立的单列索引大部分不能提高mysql的查询性能，例如：
  ```sql
  SELECT file_id, actor_id FROM sakila.film_actor
  WHERE actor_id=1 OR film_id=1;
  ```
  在比较老的版本中，Mysql对这个查询会使用全表扫描，除非改写成如下查询：
  ```sql
  SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id=1
  UNION ALL
  SELECT film_id, actor_id FROM sakila.film_actor
  WHERE film_id=1 AND actor_id<>1;
  ```
  在mysql5.0以及更高的版本中，引入了索引合并的策略，查询能够同时使用这两个单例索引进行扫描，并将结果合并，这种算法有三个变种：OR的union，AND的intersection，组合前两种情况。
  对于btree索引我们应该选用合适的索引列顺序。
  在一个多列Btree索引中，索引列的顺序意味着索引首先按照最左列进行排序，所以索引可以按照升序或降序进行扫描，以满足精确符合列顺序的ORDER BY,GROUP BY和DISTINCT等子句的查询要求，所以多列索引的索引顺序至关重要。
  4. 聚簇索引
   聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，InnoDB的聚簇索引实际上在同一个结构中保存了B-tree索引和数据行。
   当表中有聚簇索引时，他的数据行实际上存放在索引的叶子页中，术语聚簇，数据行和相邻的键值紧凑第存储在一起，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
   如果没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引，InnoDB只聚簇在同一个页面中的记录，包含相邻键值的页面可能相距甚远。
   聚集的数据有一些重要的优点：
   1. 可以把相关数据保存在一起，例如，实现电子邮箱时，可以根据用户ID来聚簇数据，这样只需要从磁盘读取少数的数据页，就能获取某个用户的全部邮件，如果没有使用聚簇索引，则没封邮件都可能导致一次磁盘IO
   2. 数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree下，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
   3. 使用覆盖索引扫描的查询可以直接使用节点中的主键值。
   聚簇索引的一些缺点：
   1. 聚簇索引最大限度地提高了IO密集型应用地性能，但如果数据全部都放在内存中，则访问地速度就没那么重要了，聚簇索引就没什么优势了。
   2. 插入速度严重依赖于插入顺序，按照主键顺序插入是加载数据到InnoDB表中速度最快地方式，但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE_TABLE命令重新组织一下表。
   3. 更新聚簇索引列地代价很高，因为会强制Innodb将每个被更新地行移动到新的位置。
   4. 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面列页分裂问题，当行的主键值要求必须将这一行插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，页分裂将导致表占用更多磁盘空间。
   5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续。
   6. 二级索引可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列，二级索引访问需要二次索引查找，而不是一次。
