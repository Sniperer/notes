# Mysql

## 逻辑架构
+ 最上层：大多数基于网络的客户端/服务器的工具或服务都有类似的架构，比如：连接管理，授权认证，安全。
+ 第二层：大多数的Mysql的核心服务都在这层，包括查询解析，分析优化，缓存以及所有的内置函数，所有的跨存储引擎的功能都在这一层实现，如储存过程，触发器，视图等。
+ 第三层：储存引擎。

## SQL四种语言
1. DDL: data definition language 用于定义数据库的三级结构，包括外模式，概念模式，内模式及其相互之间的映像，定义数据的完整性，安全控制等约束。模式就是指schema。包括CREATE、ALTER、DROP、TRUNCATE（用于删除表中的所有行且不记录单个行的删除操作，与没有where子句的DELETE语句类似，但是TRUNCATE速度更快，使用的系统资源和事务日志资源更少）、COMMENT、RENAME
  + 外模式：对应数据库的升级、外模式包括(子模式，用户模式)用来描述用户看到或使用那部分的数据的逻辑结构，用户根据外模式用户数据操作语句或者程序操作数据库中的数据，外模式的主要特点用来描述组成用户视图各个记录的组成、相互联系、数据的完整性、数据项的特征等。
  + 概念模式：概念模式（概念、逻辑模式）用以描述整个数据库中的逻辑结构、用来描述现实生活中的实体，以及他们之间的关系、从而定义记录数据项的完整性约束条件以及记录之间的联系是数据项的框架，概念模式是数据库中全体数据的逻辑结构和特征的描述，是所有用户数据的公共数据视图。
  + 内模式：内模式对应物理级数据库，内模式是所有模式最底层的表示，不同于物理层，假设外存是一个无限性的地址空间，内模式是储存记录的类型，储存域，以及储存记录的物理顺序，即元索引，和储存路径等数据的存储组织从而形成一个完整的系统。
2. DML：DATA manipulation language数据操纵语言 分为交互型和嵌入型DML，也可分为过程型DML和非过程型DML，包括SELECT、INSERT、UPDATE、DELETE、MERGE、CALL、EXPLAIN PLAN、LOCK TABLE
3. DCL：DATA control language数据库控制语言 GRANT授权，REVOKE取消授权
4. TCL：Transaction Control Language事务控制语言 SAVEPOINT 设置保存点，ROLLBACK 回滚，SET TRANSACTION

## 索引
+ ### 索引的优点
  1. 索引可以让服务器快速定位到表的指定位置。
  2. 索引大大减少了服务器需要扫描的数据量。
  3. 索引可以帮助服务器避免排序和临时表。
  4. 索引可以将随机IO变为顺序IO。
+ ### 索引的三星系统原则
  1. 索引将相关的记录放到一起则获得一星
  2. 如果索引中的数据顺序和查找中的排列顺序一致将获得二星
  3. 如果索引中的列包含了查询中需要的全部列则获得三星
+ ### B-Tree索引
  B-Tree索引适用于全键值，键值范围或键前缀查找，键前缀查找只适用根据最左前缀的查找，对如下类型的查询有效：
  1. 全值匹配：全值匹配指的是和索引中的所有列进行匹配。
  2. 匹配最左前缀：查找所有姓为Allen的人，即只使用索引的第一列。
  3. 匹配列前缀：可以匹配莫一列的值的开头部分，可以查找所有以J开头的姓的人。
  4. 匹配范围值：可用于查找在Allen和Barrymore之间的人。
  5. 精确匹配某一列并范围匹配另外一列：可用于查找所有姓为Allen，并且名字是字母K开头的人，即第一列全匹配，第二列范围匹配。
  6. 只访问索引的查询：B-Tree通常可以支持聚簇索引，即查询值需要访问索引，而无须访问数据行。
+ B-Tree索引的限制
  因为索引树的节点时有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作(按序查找)，一般来说，如果B-tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序，所以，如果ORDER BY自居满足下面的查询类型，则这个索引也可以满足对应的排序需求。
  在优化性能时，可能需要使用相同的列，但顺序不同的索引来满足不同类型的查询需求。索引的顺序很重要。
  1. 如果不是按照索引的最左列开始查找，则无法使用索引。
  2. 不能跳过索引中的列。
  3. 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。
+ ### hash索引
  哈希索引基于哈希表实现，只有精确匹配索引的所有列的查询才有效，对于每一行数据，储存引擎都会对所有的索引列计算一个哈希码，哈希码时一个较小的值，并且不同的键值的行计算出来的哈希码也不一样，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
```sql
CREATE TABLE testhash(
  fname VARCHAR(50) NOT NULL,
  lname VARCHAR(50) NOT NULL,
  KEY USING HASH(fname)
)ENGINE=MEMORY;
```
+ hash索引的限制
  1. 哈希索引值包含哈希值和行指针，而不存储字段值所以不能使用索引中的值来避免读取行，不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
  2. 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。
  3. 哈希索引也不支持部分索引匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值。
  4. 哈希索引只支持等值比较查询，包括=，IN(),<=>。也不支持任何范围查询，例如WHERE > 100。
  5. 访问哈希索引的数据非常快，除非有很多哈希冲突。
  6. 如果哈希冲突很多的话，一些索引维护操作的代价会很高。

+ 自定义哈希索引
  在B-Tree基础上创建一个伪hash索引，这和真正的hash索引不是一回事，因为还是使用B-Tree进行查找，但是使用哈希值而不是键值本身进行索引查找。但需要考虑到如果hash冲突，不单单影响效率，查询结果会返回多行，需要过滤。
  如此一来，如果需要为url使用btree索引，那么需要储存的内容将会很大，因为URL本身都很长。所以自定义哈希索引的作用之一就是只需要很小的索引就可以为超长的键创建索引。
  InooDB引擎有一个特殊的功能叫做自适应哈希索引，当InooDB注意到某些索引值被使用得非常频繁时，他会在内存中基于btree索引再创建一个哈希索引，这样就让btree索引也具有一些哈希所以的优点。
  ```sql
  CREATE TABLE pseudohash(
    id int unsigned NOT NULL auto_increment,
    url varchar(255) NOT NULL,
    url_crc int unsigned NOT NULL DEFAULT 0,
    PRIMARY KEY(id)
  );
  DELIMITER //
  CREATE TRIGGER pseudohash_crc_ins BEFORE INSERT ON
  pseudohash FOR EACH ROW BEGIN SET NEW.url_crc=crc32(NEW.URL);
  END;
  //
  CREATE TRIGGER pseudohash_crc_upd BEFORE UPDATE ON
  pseudohash FOR EACH ROW BEGIN
  SET NEW.url_crc=crc32(NEW.url);
  NED;
  //
  DELIMITER ;
  ```
+ 高性能索引策略

  1. 独立的列：索引列不能时表达式的一部分，也不能是函数的参数。不当的使用索引，或者使得Mysql无法使用已有的索引。例如：
  ```sql
  SELECT actor_id from sakila.actor WHERE actor_id + 1 = 5;
  SELECT .... WHERE TO_DAYS(CURRENT_DATE)-TO_DAYS(data_col)<=10;
  ```
  Mysql无法自动解析方程式，我们应该养成简化WHERE条件的习惯。

  2. 前缀索引和索引选择性
  索引选择性是指不重复的索引值和数据表的记录总数，从1/#T到1之间，选择性高的索引能过滤更多的行。
  有时候需要索引很长的字符列，这会让索引变得大且慢，一个策略是前面提到的模拟哈希索引，但有时候这样做还不够。
  一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能，对于BLOB，TEXT或者更长的VARCHAR类型的列，必须使用前缀索引，因为Mysql不允许若因这些列的完整长度。所以，前缀索引的诀窍在于选择足够长的前缀以保证较高的选择性，同时又不能太长，以便节约空间，前缀的基数应该接近完整列的基数。
  计算合适的前缀长度的办法：

      1. 假设现在的索引列是城市名，那么，我们先找到最常见的城市列表：
    ```sql
    SELECT COUNT(*) AS cnt, city
    FROM sakila.city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;
    ```
    然后，我们试探前缀长：
    ```sql
    SELECT COUNT(*) AS cnt, LEFT(city,3) AS pref
    FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10
    ```
    比对这两个结果，如果差点意思，增加前缀长，直到前缀基数接近完整基数。

          2. 另一个办法是，计算列的选择性，并使前缀的选择性接近于完整列的选择性。

    ```sql
    SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
    SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*) AS sel3;
    ```
          这是平均情况，还要考虑最坏情况。
  创建前缀索引的方法
  ```sql
  ALTER TABLE sakila.city_demo ADD KEY(city(7));
  ```
  缺点：无法用于ORDER BY和GROUP BY,也无法使用前缀索引做覆盖扫描。
  一个常见的业务场景：
  存储网站的session基于Mysql，那么需要在一个很长的十六进制字符串上创建索引，此时，如果采用长度为8的前缀索引通常能显著地提升性能。
  有时候，后缀索引也有用途，例如，找到某个域名的所有电子邮件地址，Mysql并不支持反向索引，但可以把字符串反转后存储，并基于此建立前缀索引，可以用触发器维护这种索引。

  3. 多列索引
  在多个列上建立的单列索引大部分不能提高mysql的查询性能，例如：
  ```sql
  SELECT file_id, actor_id FROM sakila.film_actor
  WHERE actor_id=1 OR film_id=1;
  ```
  在比较老的版本中，Mysql对这个查询会使用全表扫描，除非改写成如下查询：
  ```sql
  SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id=1
  UNION ALL
  SELECT film_id, actor_id FROM sakila.film_actor
  WHERE film_id=1 AND actor_id<>1;
  ```
  在mysql5.0以及更高的版本中，引入了索引合并的策略，查询能够同时使用这两个单例索引进行扫描，并将结果合并，这种算法有三个变种：OR的union，AND的intersection，组合前两种情况。
  对于btree索引我们应该选用合适的索引列顺序。
  在一个多列Btree索引中，索引列的顺序意味着索引首先按照最左列进行排序，所以索引可以按照升序或降序进行扫描，以满足精确符合列顺序的ORDER BY,GROUP BY和DISTINCT等子句的查询要求，所以多列索引的索引顺序至关重要。

  4. 聚簇索引
   聚簇索引并不是一种单独的索引类型，而是一种数据存储方式，InnoDB的聚簇索引实际上在同一个结构中保存了B-tree索引和数据行。
   当表中有聚簇索引时，他的数据行实际上存放在索引的叶子页中，术语聚簇，数据行和相邻的键值紧凑第存储在一起，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
   如果没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键作为聚簇索引，InnoDB只聚簇在同一个页面中的记录，包含相邻键值的页面可能相距甚远。
   聚集的数据有一些重要的优点：
      1. 可以把相关数据保存在一起，例如，实现电子邮箱时，可以根据用户ID来聚簇数据，这样只需要从磁盘读取少数的数据页，就能获取某个用户的全部邮件，如果没有使用聚簇索引，则没封邮件都可能导致一次磁盘IO
      2. 数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree下，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
      3. 使用覆盖索引扫描的查询可以直接使用节点中的主键值。

      聚簇索引的一些缺点：

      1. 聚簇索引最大限度地提高了IO密集型应用地性能，但如果数据全部都放在内存中，则访问地速度就没那么重要了，聚簇索引就没什么优势了。

      2. 插入速度严重依赖于插入顺序，按照主键顺序插入是加载数据到InnoDB表中速度最快地方式，但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE_TABLE命令重新组织一下表。

      3. 更新聚簇索引列地代价很高，因为会强制Innodb将每个被更新地行移动到新的位置。

      4. 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面列页分裂问题，当行的主键值要求必须将这一行插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，页分裂将导致表占用更多磁盘空间。

      5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续。

      6. 二级索引可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列，二级索引访问需要二次索引查找，而不是一次。

      二级索引：

        1. 叶子节点中存储主键值，每次查找数据时，根据索引找到叶子节点中的主键值，根据主键值在聚簇索引中得到完整的记录。

        2. 二级索引会占据更多的空间，但InnoDB在移动行时，无需维护二级索引，因为叶子节点中存储的是主键值，而不是指针。

        3. InnoDB有了聚簇索引为什么需要二级索引？聚簇索引的叶子节点存储了一行完整的数据，而二级索引只存储了主键值，相比于聚簇索引，占用的空间少，当我们需要为表建立多个索引时，如果都是聚簇索引将占据大量内存空间，所以InnoDB中主键所建立的是聚簇索引，而唯一索引，普通索引，前缀索引等都是二级索引。

        4. 为什么一般情况下，建表的时候会使用一个自增的id来作为我们的主键？InnoDB中表的数据是直接存储在主键聚簇索引的叶子节点中，每插入一条记录，其实都是增加一个叶子节点，只需要把新增的一条记录存储在上一条记录的后面，当页达到最大填充因子的时候，下一次记录就会写入新的页中，这种情况下，主键页就会被近似顺序的记录填满。若表的主键不是顺序id，而是无规律数据，比如字符串，InnoDB会寻找一个合适的位置，甚至产生大量的页分裂并且大量移动数据，在寻找合适位置插入时，目标页可能不在内存中，这就导致了大量随机IO，影响插入效率。大量的页分裂会产生内存碎片。但是，使用顺序的主键，对于高并发的工作负载，主键的上界会成为热点，因为所有的插入都发生在这里，并发插入可能导致间隙锁竞争，另一个热点，可能时AUTO_INCREMENT锁机制。遇到这种问题可能需要考虑重新设计表或者应用，或者更改innodb_autoinc_lock_mode配置。

    5. 覆盖索引 如果一个索引覆盖了所有需要查询的字段的值，我们就称之为覆盖索引。Mysql只能用btree索引做覆盖索引，哈希索引，空间索引和全文索引都不存储索引列的值。InnoDB在二级索引使用共享锁，但访问主键索引需要排他锁。优点：

        1. 索引条目通常远小于数据行大小，如果只读索引，Mysql就会极大地减少数据访问量，这对缓存的负载非常重要，同时有利于将所需数据完全压入内存。
        2. 因为索引是按照列值顺序存储的(至少在单个页内如此)，所以对于IO密集型的范围查询会比从磁盘内随机IO要少很多。
        3. 一些储存引擎在内存中只缓存索引，数据则依赖于操作系统缓存，因为此要访问数据需要一次系统调用。
        4. 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用，InnoDB二级索引在叶子节点保存了行的主键值，如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

+ 锁机制
Record Locks 行锁（锁住索引记录），GAP LOCKs 间隙锁，Next-Key locks 行锁锁住了当前的索引记录，GapLocks锁住了从上一个索引记录到当前索引记录的间隙，也就是(pri.index,now.index]
1. Intention LOCKs 意向锁，为实现行级和表级的多粒度而设计，意向锁是指明事务在表中的某行需求（X or S）的表级所，有以下两种：

    1. IS锁意向共享锁，指明一个事务将在表中某些行申请S锁。SELECT ... LOCK IN SHARE MODE
    2. IX锁意向排他锁，指明一个十五将在表中某些行申请X锁。SELECT ... FOR UPDATE

使用规则如下：在一个事务要获得S锁前，必须获得IS锁或IX锁，在一个事务要获得X锁之前，必须获得IX锁。除了对全表级进行锁请求之外，意向锁不会阻塞任何请求，意向锁的设计目的是用来表示有的操作正在锁住一些行，或者将要锁住。SELECT ... FOR UPDATE 申请了IX锁后也进行了RECORD LOCKS 锁住了索引记录，阻塞Insert,UPDATE,delete在当前索引记录上。

2. Gap Locks 间隙锁权衡了并发和性能。唯一目的是防止其他事务插入数据，只存在与RR和Serializable隔离级别中存在，间隙共享和间隙排他没有区别，间隙锁可以兼容，因为唯一的目的是抑制插入，两事务进行插入或删除都必须合并间隙锁，这达到了间隙锁的目的。
